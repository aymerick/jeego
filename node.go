package main

import (
	"fmt"
	"log"
	"strconv"
)

// node kinds
const (
	ROOM_NODE = "roomNode"
	THL_NODE  = "thlNode"
)

// sensors kinds
const (
	TEMP_SENSOR   = 1 << iota
	HUMI_SENSOR   = 1 << iota
	LIGHT_SENSOR  = 1 << iota
	MOTION_SENSOR = 1 << iota
	LOWBAT_SENSOR = 1 << iota
)

type Sensor uint

var SensorsForKind map[string]Sensor

func init() {
	SensorsForKind = map[string]Sensor{
		ROOM_NODE: TEMP_SENSOR + HUMI_SENSOR + LIGHT_SENSOR + LOWBAT_SENSOR + MOTION_SENSOR,
		THL_NODE:  TEMP_SENSOR + HUMI_SENSOR + LIGHT_SENSOR + LOWBAT_SENSOR,
	}
}

// Node
type Node struct {
	Id          byte   `json:"id"`
	Kind        string `json:"kind"`
	Name        string `json:"name"`
	DomoticzIdx string `json:"domoticz_idx"`

	// sensors
	Temperature float32
	Humidity    uint8
	Light       uint8
	Motion      bool
	LowBattery  bool
}

func (node *Node) handleData(data []byte) {
	switch node.Kind {
	case ROOM_NODE:
		node.handleRoomNodeData(data)
	case THL_NODE:
		node.handleThlNodeData(data)
	default:
		log.Panic("Unsupported node kind: " + node.Kind)
	}
}

func (node *Node) haveSensor(sensor Sensor) bool {
	return ((SensorsForKind[node.Kind] & sensor) != 0)
}

// Example of line generated by RF12Demo sketch that received a packet from a standard roomNode:
//
//       OK 2 156 149 213 0
//          ^ -------------
//     header      ^
//             data bytes
//
//
// roomNode payload structure:
//
//     struct {
//         byte light;     // light sensor: 0..255
//         byte moved :1;  // motion detector: 0..1
//         byte humi  :7;  // humidity: 0..100
//         int temp   :10; // temperature: -500..+500 (tenths)
//         byte lobat :1;  // supply voltage dropped under 3.1V: 0..1
//     } payload;
//
//
// data bytes decoding:
//
//             156 => 1 0 0 1 1 1 0 0
//             149 => 1 0 0 1 0 1 0 1
//             213 => 1 1 0 1 0 1 0 1
//               0 => 0 0 0 0 0 0 0 0
//
//             light: 1 0 0 1 1 1 0 0 => 156 * 100 / 255 = 61
//             moved:               1 => true
//          humidity: 1 0 0 1 0 1 0   => 74
//       temperature: 1 1 0 1 0 1 0 1 => 213 / 10 = 21.3
//                                0 0
//       low battery:           0     => false
//        <not used>: 0 0 0 0 0
//
// References:
//   - http://jeelabs.org/2011/06/09/rf12-packet-format-and-design/
//   - http://jeelabs.org/2011/01/14/nodes-addresses-and-interference/
//   - http://jeelabs.org/2010/12/07/binary-packet-decoding/
//   - http://jeelabs.org/2010/12/08/binary-packet-decoding-â€“-part-2/
//   - http://jeelabs.org/2013/09/05/decoding-bit-fields/
//   - http://jeelabs.org/2013/09/06/decoding-bit-fields-part-2/
//
func (node *Node) handleRoomNodeData(data []byte) {
	if len(data) == 4 {
		var temperature int = ((256 * (int(data[3]) & 3)) + int(data[2]))
		if temperature > 512 {
			// negative value
			temperature = temperature - 1024
		}

		node.Light = uint8((int(data[0]) * 100) / 255)
		node.Motion = ((data[1] & 1) == 1)
		node.Humidity = data[1] >> 1
		node.Temperature = float32(temperature) / 10
		node.LowBattery = (((data[3] >> 2) & 1) == 1)
	}
}

// Example of line generated by RF12Demo sketch that received a packet from a thlNode:
//
//       OK 3 03 184 100 210 0
//          ^ -------------
//     header      ^
//             data bytes
//
//
// thlNode payload structure:
//
//      struct {
//        byte light;     // light sensor: 0..255
//        byte lobat :1;  // supply voltage dropped under 3.1V: 0..1
//        byte humi  :7;  // humidity: 0..100
//        int  temp  :10; // temperature: -512..+512 (tenths)
//      } payload;
//
//
// data bytes decoding:
//
//             184 => 1 0 1 1 1 0 0 0
//             100 => 0 1 1 0 0 1 0 0
//             210 => 1 1 0 1 0 0 1 0
//               0 => 0 0 0 0 0 0 0 0
//
//             light: 1 0 1 1 1 0 0 0 => 184 * 100 / 255 = 72
//       low battery:               0 => true
//          humidity: 0 1 1 0 0 1 0   => 50
//       temperature: 1 1 0 1 0 0 1 0
//                                0 0 => 210 / 10 = 21.0
//        <not used>: 0 0 0 0 0 0
//
func (node *Node) handleThlNodeData(data []byte) {
	if len(data) == 4 {
		var temperature int = ((256 * (int(data[3]) & 3)) + int(data[2]))
		if temperature > 512 {
			// negative value
			temperature = temperature - 1024
		}

		node.Light = uint8((int(data[0]) * 100) / 255)
		node.LowBattery = ((data[1] & 1) == 1)
		node.Humidity = data[1] >> 1
		node.Temperature = float32(temperature) / 10
	}
}

func (node *Node) textData() string {
	result := ""

	result += node.Name + ":"

	if node.haveSensor(TEMP_SENSOR) {
		result += "\n  Temperature: " + strconv.FormatFloat(float64(node.Temperature), 'f', 1, 64)
	}

	if node.haveSensor(HUMI_SENSOR) {
		result += "\n  Humidity: " + strconv.Itoa(int(node.Humidity))
	}

	if node.haveSensor(LIGHT_SENSOR) {
		result += "\n  Light: " + strconv.Itoa(int(node.Light))
	}

	if node.haveSensor(MOTION_SENSOR) {
		result += "\n  Motion: " + strconv.FormatBool(node.Motion)
	}

	if node.haveSensor(LOWBAT_SENSOR) {
		result += "\n  LowBattery: " + strconv.FormatBool(node.LowBattery)
	}

	result += "\n\n"

	return result
}

func (node *Node) domoticzValue() string {
	// @todo Send others sensors values to domoticz
	return fmt.Sprintf("%.1f;%d;0", node.Temperature, node.Humidity)
}
