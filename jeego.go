package main

import (
	"errors"
	"log"
	"strconv"
	"strings"
)

func main() {
	// @todo configurize that
	nodes := make(map[byte]INode, 2)
	nodes[2] = &RoomNode{Node: Node{2, "RoomNode test"}}
	nodes[3] = &ThlNode{Node: Node{3, "ThlNode test"}}

	// serial reader
	sr := NewSerialReader()

	// loop forever
	for {
		// read a line and trim it
		line := strings.Trim(sr.readLine(), " \n\r")
		if line != "" {
			log.Printf("Received: %s", line)

			// parse node id and data
			nodeId, data, err := parseLine(line)
			if err == nil {
				// get node
				node := nodes[nodeId]
				if node != nil {
					// handle data
					node.handleData(data)

					// debug
					node.dump()
				} else {
					// unknown node
					log.Printf("Ignoring unknown node: %v", nodeId)
				}
			}
		}
	}
}

// Example of line generated by RF12Demo sketch that received a packet from a standard roomNode:
//
//       OK 2 156 149 213 0
//          ^ -------------
//     header      ^
//             data bytes
//
//
// header:
//
//      0   0   0   0   0   0   1   0
//      ^   ^   ^   -----------------
//     CTL DST ACK          ^
//                       node id => 2
func parseLine(line string) (nodeId byte, data []byte, err error) {
	// split line
	dataStrArray := strings.Split(line, " ")

	// parse status
	if dataStrArray[0] == "OK" {
		// parse node id
		nodeId = byteFromString(dataStrArray[1]) & 0x1f

		// parse data
		data = make([]byte, len(dataStrArray)-2)

		for index, dataStr := range dataStrArray {
			if index > 1 {
				data[index-2] = byteFromString(dataStr)
			}
		}
	} else {
		err = errors.New("Garbage received")
	}

	return
}

// helper
func byteFromString(val string) byte {
	i, err := strconv.ParseUint(val, 10, 8)
	if err != nil {
		log.Panic(err)
	}

	return byte(i)
}
