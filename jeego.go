//
// Run with: $ go run centralNode.go
//

package main

import (
    "github.com/tarm/goserial"
    "io"
    "log"
    "strconv"
    "strings"
)

const (
    PORT_NAME = "/dev/tty.usbserial-A1014IM4"
    PORT_BAUD = 57600
    LF_CHAR   = 10
)

type RoomNodeData struct {
    node_id     uint8
    temperature float32
    humidity    uint8
    light       uint8
    motion      bool
    low_battery bool
}

func readLine(ser io.ReadWriteCloser) string {
    result := make([]byte, 0)
    lastRead := make([]byte, 1)

    // read byte by byte until the Line Feed character
    for lastRead[0] != LF_CHAR {
        n, err := ser.Read(lastRead)
        if (err != nil) || (n != 1) {
            log.Panic(err)
        }

        result = append(result, lastRead[0])
    }

    return string(result)
}

func _byteFromString(val string) byte {
    i, err := strconv.ParseUint(val, 10, 8)
    if err != nil {
        log.Panic(err)
    }

    return byte(i)
}

// Example of line generated by RF12Demo sketch that received a packet from a standard roomNode:
//
//       OK 2 156 149 213 0
//          ^ -------------
//     header      ^
//             data bytes
//
//
// header:
//
//      0   0   0   0   0   0   1   0
//      ^   ^   ^   -----------------
//     CTL DST ACK          ^
//                       node id => 2
//
//
// roomNode payload structure:
//
//     struct {
//         byte light;     // light sensor: 0..255
//         byte moved :1;  // motion detector: 0..1
//         byte humi  :7;  // humidity: 0..100
//         int temp   :10; // temperature: -500..+500 (tenths)
//         byte lobat :1;  // supply voltage dropped under 3.1V: 0..1
//     } payload;
//
//
// data bytes decoding:
//
//             156 => 1 0 0 1 1 1 0 0
//             149 => 1 0 0 1 0 1 0 1
//             213 => 1 1 0 1 0 1 0 1
//               0 => 0 0 0 0 0 0 0 0
//
//             light: 1 0 0 1 1 1 0 0 => 156 * 100 / 255 = 61
//             moved:               1 => true
//          humidity: 1 0 0 1 0 1 0   => 74
//       temperature: 1 1 0 1 0 1 0 1 => 213 / 10 = 21.3
//                                0 0
//       low battery:           0     => false
//        <not used>: 0 0 0 0 0
//
// References:
//   - http://jeelabs.org/2011/06/09/rf12-packet-format-and-design/
//   - http://jeelabs.org/2011/01/14/nodes-addresses-and-interference/
//   - http://jeelabs.org/2010/12/07/binary-packet-decoding/
//   - http://jeelabs.org/2010/12/08/binary-packet-decoding-â€“-part-2/
//   - http://jeelabs.org/2013/09/05/decoding-bit-fields/
//   - http://jeelabs.org/2013/09/06/decoding-bit-fields-part-2/
//
func parseLine(line string) *RoomNodeData {
    log.Printf("Received: %s", line)

    data := strings.Split(line, " ")

    if (len(data) == 6) && (data[0] == "OK") {
        result := new(RoomNodeData)
        result.node_id = uint8(_byteFromString(data[1]) & 0x1f)

        dataByte1 := _byteFromString(data[2])
        dataByte2 := _byteFromString(data[3])
        dataByte3 := _byteFromString(data[4])
        dataByte4 := _byteFromString(data[5])

        var temperature int = ((256 * (int(dataByte4) & 3)) + int(dataByte3))
        if temperature > 512 {
            // negative value
            temperature = temperature - 1024
        }

        result.light = uint8((int(dataByte1) * 100) / 255)
        result.motion = ((dataByte2 & 1) == 1)
        result.humidity = dataByte2 >> 1
        result.temperature = float32(temperature) / 10
        result.low_battery = (((dataByte4 >> 2) & 1) == 1)

        return result
    } else {
        return nil
    }
}

func handleData(data *RoomNodeData) {
    log.Printf("Decoded:")
    log.Printf("  node_id: %d", data.node_id)
    log.Printf("  temperature: %f", data.temperature)
    log.Printf("  humidity: %d", data.humidity)
    log.Printf("  light: %d", data.light)
    log.Printf("  motion: %t", data.motion)
    log.Printf("  low_battery: %t", data.low_battery)
}

func main() {
    // @todo Settingfy port
    conf := &serial.Config{Name: PORT_NAME, Baud: PORT_BAUD}
    ser, err := serial.OpenPort(conf)
    if err != nil {
        log.Panic(err)
    }

    // loop forever
    for {
        // read a line and trim it
        line := strings.Trim(readLine(ser), " \n\r")
        if line != "" {
            // parse line
            data := parseLine(line)
            if data != nil {
                // handle parsed data
                handleData(data)
            }
        }
    }
}
