package main

import (
	"errors"
	"fmt"
	"log"
	"os"
	"runtime"
	"strconv"
	"strings"
)

func main() {
	log.SetOutput(os.Stderr)

	log.Printf("Jeego - Target OS/Arch: %s %s", runtime.GOOS, runtime.GOARCH)
	log.Printf("Built with Go Version: %s", runtime.Version())

	// load config
	config, err := loadConfig()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error loading configuration: \n\n%s\n", err)
		return
	}

	log.Printf("Jeego config: %+v", config)

	// @todo A better web service
	// launch web server
	// go runWebServer(config)

	// @todo Goify serial reader ?
	// serial reader
	sr := NewSerialReader(config.SerialPort, config.SerialBaud)

	// loop forever
	for {
		// read a line and trim it
		line := strings.Trim(sr.readLine(), " \n\r")
		if line != "" {
			if config.Debug {
				log.Printf("Received: %s", line)
			}

			// parse node id and data
			nodeId, data, err := parseLine(line)
			if err == nil {
				// get node
				node := config.NodeForId(nodeId)
				if node != nil {
					// handle data
					node.handleData(data)

					// debug
					if config.Debug {
						log.Printf(node.textData())
					}

					// push to domoticz
					go pushToDomoticz(config, node)
				} else {
					// unknown node
					log.Printf("Ignoring unknown node: %v", nodeId)
				}
			}
		}
	}
}

// Parse a line received from central node
//
// Example of line generated by RF12Demo sketch that received a packet from a standard roomNode:
//
//       OK 2 156 149 213 0
//          ^ -------------
//     header      ^
//             data bytes
//
//
// header:
//
//      0   0   0   0   0   0   1   0
//      ^   ^   ^   -----------------
//     CTL DST ACK          ^
//                       node id => 2
func parseLine(line string) (nodeId byte, data []byte, err error) {
	// split line
	dataStrArray := strings.Split(line, " ")

	// parse status
	if dataStrArray[0] == "OK" {
		// parse node id
		nodeId = byteFromString(dataStrArray[1]) & 0x1f

		// parse data
		data = make([]byte, len(dataStrArray)-2)

		for index, dataStr := range dataStrArray {
			if index > 1 {
				data[index-2] = byteFromString(dataStr)
			}
		}
	} else {
		err = errors.New("Garbage received")
	}

	return
}

// helper
func byteFromString(val string) byte {
	i, err := strconv.ParseUint(val, 10, 8)
	if err != nil {
		log.Panic(err)
	}

	return byte(i)
}
