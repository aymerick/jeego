package main

import (
	"errors"
	"fmt"
	"strconv"
	"strings"
	"time"

	log "code.google.com/p/log4go"
)

// Rf12demo Data Log
type Rf12demoDataLog struct {
	nodeId   int
	nodeKind int
	data     []byte
	at       time.Time
}

// Start RF12demo handler
func runRf12demoHandler(jeego *Jeego) chan string {
	inputChan := make(chan string, 1)

	go func() {
		var line string
		var loggerChan chan string

		if jeego.config.Rf12demoLogFile != "" {
			loggerChan = runRf12demoLogger(jeego)
		}

		// loop forever
		for {
			line = <-inputChan

			// parse node infos and data
			dataLog, err := parseLine(line)
			if err == nil {
				if loggerChan != nil {
					// log raw data log
					loggerChan <- fmt.Sprintf("[%s] %s", dataLog.at.Format(time.RFC3339), line)
				}

				// get node
				node := jeego.database.nodeForId(dataLog.nodeId)
				if node == nil {
					// insert new node in database
					node = jeego.database.insertNode(dataLog.nodeId, dataLog.nodeKind)

					// debug
					node.logDebug("Added to database")
				} else if node.Kind != dataLog.nodeKind {
					// debug
					node.logDebug(fmt.Sprintf("Kind changed from %d to %d", node.Kind, dataLog.nodeKind))

					node.Kind = dataLog.nodeKind

					// reset sensors values
					node.resetSensors()
				}

				node.LastSeenAt = time.Now().UTC()

				// handle data
				node.handleData(dataLog.data)

				// debug
				node.logDebug(node.textData())

				// update database
				jeego.database.updateNode(node)

				// push to domoticz
				go pushToDomoticz(jeego.config, node)

				// @todo insert in InfluxDB
			}
		}
	}()

	return inputChan
}

// Start RF12demo logger
func runRf12demoLogger(jeego *Jeego) chan string {
	inputChan := make(chan string, 1)

	go func() {
		var line string

		flw := log.NewFileLogWriter(jeego.config.Rf12demoLogFile, false)
		flw.SetFormat("%M")
		flw.SetRotate(true)
		flw.SetRotateSize(0)
		flw.SetRotateLines(0)
		flw.SetRotateDaily(true)

		rawLogger := log.NewDefaultLogger(log.DEBUG)
		rawLogger.AddFilter("file", log.INFO, flw)

		log.Info("Logging RF12demo data to file: %s", jeego.config.Rf12demoLogFile)

		// loop forever
		for {
			line = <-inputChan

			rawLogger.Info(line)
		}
	}()

	return inputChan
}

// Parse a line received from central node
//
// Example of line generated by RF12Demo sketch that received a packet from a jeeRoomNode:
//
//       OK 2 3 156 149 213 0
//          ^ ^ -------------
//     header |      ^
//            |  data bytes
//            |
//         node kind
//
// header:
//
//      0   0   0   0   0   0   1   0
//      ^   ^   ^   -----------------
//     CTL DST ACK         ^
//                    node id => 2
//
// node kind:
//
//      0   0   0   0   0   0   1   1
//      ^   -------------------------
// reserved            ^
//               node kind => 3
func parseLine(line string) (dataLog *Rf12demoDataLog, err error) {
	// split line
	dataStrArray := strings.Split(line, " ")

	// parse status
	if (len(dataStrArray) > 3) && (dataStrArray[0] == "OK") {
		// parse node infos
		nodeInfosByte := byteFromString(dataStrArray[2])

		// check reserved field
		if (nodeInfosByte & 0x80) != 0 {
			err = errors.New("Received payload with reserved field set to 1")
			log.Error(err)
		} else {
			dataLog = &Rf12demoDataLog{at: time.Now().UTC()}

			// parse node id
			dataLog.nodeId = int(byteFromString(dataStrArray[1]) & 0x1f)

			// parse node kind
			dataLog.nodeKind = int(nodeInfosByte & 0x7f)

			// parse data
			dataLog.data = make([]byte, len(dataStrArray)-3)

			for index, dataStr := range dataStrArray {
				if index > 2 {
					dataLog.data[index-3] = byteFromString(dataStr)
				}
			}
		}
	} else {
		err = errors.New("Garbage received")
	}

	return
}

// helper
func byteFromString(val string) byte {
	i, err := strconv.ParseUint(val, 10, 8)
	if err != nil {
		panic(log.Critical(err))
	}

	return byte(i)
}
